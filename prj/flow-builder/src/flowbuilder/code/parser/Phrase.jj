options{  ERROR_REPORTING = true;  STATIC = false;  IGNORE_CASE = true;}PARSER_BEGIN(Phrase)package flowbuilder.code.parser;import java.io.Reader;import java.io.StringReader;import flowbuilder.code.structure.Call;import flowbuilder.code.structure.Code;import flowbuilder.code.structure.Step;public class Phrase{  public static Code parsePhrase(Reader in) throws ParseException  {    return new Phrase(in).parsePhrase();  }  public static Code parsePhrase(CharSequence code) throws ParseException  {    return parsePhrase(new StringReader(code.toString()));  }}PARSER_END(Phrase)SKIP :{  " "| "\r"| "\t"| "\n"}TOKEN : /*reserved words*/{  < CALL : "call" >}TOKEN : /* rules */{  < ID : (~[ "\r", "\t", "\n", " " ])+ >}String remaining() :{  StringBuilder builder = new StringBuilder();}{  (    < ID >    {      builder.append(getToken(0).image.trim()).append(' ');    }  )+  {    //Último espaço    builder.delete(builder.length() - 1, builder.length());    return builder.toString();  }}Code parsePhrase() :{  Code c;  String s;}{  (    < CALL > s = remaining()    {      c = new Call(s);    }  | s = remaining()    {      c = new Step(s);    }  )  {    return c;  }}
